"""Vulnerability intelligence and database management"""

import sys
import json
import csv
import io
import requests
from pathlib import Path
from collections import defaultdict
from utils.printer import Printer
from config import CONFIG


class ThreatIntel:
    """Manages CVE database and threat intelligence resources"""

    @staticmethod
    def initialize_environment():
        """Initialize required directories and download databases"""
        Path('reports').mkdir(exist_ok=True)
        Path('reports/history').mkdir(exist_ok=True)
        Path('exploits').mkdir(exist_ok=True)
        Path('data').mkdir(exist_ok=True)

        required_files = {
            'data/cve_db.json': CONFIG['cve_db_url'],
            'data/directories.txt': CONFIG['dir_list_url'],
            'data/subdomains.txt': CONFIG['subdomain_list_url'],
            'data/exploit_db.csv': CONFIG['exploit_db_csv_url']
        }

        for filename, url in required_files.items():
            if not Path(filename).exists():
                ThreatIntel.download_resource(url, filename)

    @staticmethod
    def search_exploit_db_csv(service_name, service_version='', max_results=3):
        """
        Search Exploit-DB CSV database locally for exploits.

        Args:
            service_name: Name of the service (e.g., 'apache', 'nginx')
            service_version: Version string (optional)
            max_results: Maximum number of results to return

        Returns:
            list: List of exploit dictionaries with id, description, url
        """
        exploit_db_path = Path('data/exploit_db.csv')

        if not exploit_db_path.exists():
            Printer.warning("Exploit-DB database not found, skipping exploit search")
            return []

        try:
            exploits = []
            search_term = f"{service_name} {service_version}".lower().strip()

            with open(exploit_db_path, 'r', encoding='utf-8', errors='ignore') as f:
                reader = csv.DictReader(f)

                for row in reader:
                    # Check if service name matches in description or file
                    description = row.get('description', '').lower()
                    file_name = row.get('file', '').lower()

                    if service_name.lower() in description or service_name.lower() in file_name:
                        exploit_id = row.get('id', 'N/A')
                        exploits.append({
                            'id': exploit_id,
                            'description': row.get('description', 'No description'),
                            'url': f"https://www.exploit-db.com/exploits/{exploit_id}"
                        })

                        if len(exploits) >= max_results:
                            break

            return exploits

        except Exception as e:
            Printer.warning(f"Exploit-DB CSV search failed: {str(e)}")
            return []

    @staticmethod
    def download_resource(url, filename):
        """Download and process external resources"""
        try:
            response = requests.get(url, timeout=30, stream=True)

            if filename.endswith('cve_db.json'):
                # Handle CSV-to-JSON conversion with proper encoding
                cve_data = defaultdict(list)

                # Decode content using latin-1 to handle all byte values
                content = response.content.decode('latin-1')
                reader = csv.DictReader(io.StringIO(content), delimiter=',')

                for row in reader:
                    try:
                        if 'Name' in row and row['Name']:
                            parts = row['Name'].split('|')
                            if len(parts) > 1:
                                software = parts[1].lower().strip()
                                cve_entry = {
                                    'cve': parts[0].strip(),
                                    'severity': row.get('Phase', 'N/A').strip(),
                                    'description': row.get('Description', 'No description')
                                        .encode('latin-1').decode('utf-8', 'ignore').strip()
                                }
                                cve_data[software].append(cve_entry)
                    except UnicodeDecodeError as ude:
                        Printer.warning(f"Skipping row with invalid characters: {str(ude)}")
                        continue

                # Save with UTF-8 encoding and ensure_ascii=False
                with open(filename, 'w', encoding='utf-8') as f:
                    json.dump(cve_data, f, indent=2, ensure_ascii=False)

            else:
                # Handle other files with UTF-8 encoding
                with open(filename, 'wb') as f:
                    f.write(response.content)

            Printer.success(f"Processed {filename}")

        except Exception as e:
            Printer.error(f"Failed to process {filename}: {str(e)}")
            sys.exit(1)
